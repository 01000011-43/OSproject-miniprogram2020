# 2020/9/20

许茂泽

## 1. 代码实践

### （1）疾病传染--并查集

输入包含多个测试用例, 每个测试用例第一行为两个整数 n和 m, 其中 n in (0,30000])表示学生总数, 
每个同学按从 0 到 n-1进行编号, min [0,500])表示宿舍楼和教学楼的总数. 接下来是 m行, 
每一行表示一个教学楼或宿舍楼, 并且每一行以整数 k开始, 表示到过该楼里的学生人数, 紧接着 k个整数(用空格分隔), 
每个整数表示到过当前楼里的学生编号.
对于每一组输入, 都假定第 0 号学生被诊断为疑似病例.
m,n均为 0 时输入结束, 该用例不用处理. 

```c++
#include<stdio.h>
#include<iostream>
#include<stdlib.h>
using namespace std;

int  father[30010];

//查找根节点，顺便压缩路径
int findfa(int n){
	if(father[n]==n){
		return n;
	}
	else{
		int tmp=findfa(father[n]);
		father[n]=tmp;
		return tmp;
	}
}

int main(){
	int n,m;
	cin>>n>>m;
	while(n||m){
		for(int i=0;i<n;i++){
			father[i]=i;
		}
		for(int i=0;i<m;i++){
			int num;
			cin>>num;
			int first;
			cin>>first;
			first=findfa(first);//先记录第一个同学的根结点
			for(int j=1;j<num;j++){
				int second;
				cin>>second;
				second=findfa(second);
				father[second]=first;//后面同学都连到第一个同学那里 
			}
		}
		int sickfather=findfa(0); //0号病人所在根结点
		int sum=0;
		for(int i=0;i<n;i++){
			int fa=findfa(i);
			if(fa==sickfather){
				sum++;
			}
		}
		cout<<sum<<endl;
		cin>>n>>m;
	}
	return 0;
}
```

###  （2）求集合的子集--回溯

**与之前做过的全排列不同，递归程序中每次尝试的不是不同的数字，而是该位数字要不要加入到集合中**

LeetCode78

给定一组不含重复元素的整数数组 *nums*，返回该数组所有可能的子集（幂集）。

```c++
class Solution {
public:
    vector<vector<int>> ans;
    vector<int> tmp;
    void dfs(int cur,vector<int>& nums){
        if(cur==nums.size()){
            ans.push_back(tmp);
            return ;
        }
        //不选择当前位置的数
        dfs(cur+1,nums);

        //选择当前位置的数
        tmp.push_back(nums[cur]);
        dfs(cur+1,nums);
        //回溯
        tmp.pop_back();    
    }
    
    
    vector<vector<int>> subsets(vector<int>& nums) {
        dfs(0,nums);
        return ans;
    }
};
```

## 2. 计算机基础知识

